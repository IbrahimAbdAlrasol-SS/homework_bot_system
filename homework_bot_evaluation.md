 Ù…Ø§ Ø§Ù„Ø°ÙŠ ØªØ¨Ù‚Ù‰ØŸ - Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª
Ø¨Ø¹Ø¯ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠØŒ Ø¥Ù„ÙŠÙƒ Ù…Ø§ ØªØ¨Ù‚Ù‰ ÙˆØªØ±ØªÙŠØ¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª:
ğŸ”´ Ø£ÙˆÙ„ÙˆÙŠØ© Ø¹Ø§Ù„ÙŠØ© (ÙŠØ¬Ø¨ Ø¥Ù†Ø¬Ø§Ø²Ù‡Ø§ Ø£ÙˆÙ„Ø§Ù‹)

ØªØ·Ø¨ÙŠÙ‚ Bot Telegram âš ï¸

Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£ÙŠ ÙƒÙˆØ¯ Ù„Ù„Ø¨ÙˆØª Ù†ÙØ³Ù‡
ÙŠØ­ØªØ§Ø¬ Ø¥Ù†Ø´Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ Ù…Ù†ÙØµÙ„ Ù„Ù„Ø¨ÙˆØª
Ø±Ø¨Ø· Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ API
Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…

Ø¥Ø¶Ø§ÙØ© Ù†Ø¸Ø§Ù… Ø§Ù„ØªØµÙˆÙŠØª Ù„Ù„Ù…Ù†Ø§ÙØ³Ø©
Ù…Ù†Ø¹ Ø§Ù„ØºØ´ ÙÙŠ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„ÙˆØ§Ø¬Ø¨Ø§Øª
Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø´Ù‡Ø±ÙŠØ©


Ù†Ø¸Ø§Ù… Ù…Ù†Ø¹ Ø§Ù„ØºØ´

Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ÙˆØ¯ Ù„Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„ÙˆØ§Ø¬Ø¨Ø§Øª
ØªØªØ¨Ø¹ Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„ØºØ´



ğŸŸ¡ Ø£ÙˆÙ„ÙˆÙŠØ© Ù…ØªÙˆØ³Ø·Ø©

Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ

ØªØ­Ù„ÙŠÙ„ Ø³Ù„ÙˆÙƒ Ø§Ù„Ø·Ù„Ø§Ø¨
Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø®ØµØµØ©
Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø§Ù„Ø£Ø¯Ø§Ø¡


Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ©

WebSocket Ù„Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ©
Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Telegram


Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… ÙˆÙŠØ¨

ÙˆØ§Ø¬Ù‡Ø© Ù„Ù„Ø£Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø³Ø¤ÙˆÙ„
ØªÙ‚Ø§Ø±ÙŠØ± ØªÙØ§Ø¹Ù„ÙŠØ©
Ø¥Ø¯Ø§Ø±Ø© Ø³Ù‡Ù„Ø©



ğŸŸ¢ Ø£ÙˆÙ„ÙˆÙŠØ© Ù…Ù†Ø®ÙØ¶Ø©

Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª ÙˆØ§Ù„Ø¥Ø¶Ø§ÙØ§Øª

Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¨ÙŠÙ† Ø§Ù„Ø£Ù‚Ø±Ø§Ù†
Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©



ğŸ› Ø§Ù„Ø¹ÙŠÙˆØ¨ Ø§Ù„ØªÙŠ ÙŠØ¬Ø¨ Ø¥ØµÙ„Ø§Ø­Ù‡Ø§
1. Ø¹ÙŠÙˆØ¨ ÙÙŠ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø­Ø§Ù„ÙŠ
Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ù†Ù…ÙˆØ°Ø¬ Assignment:
python# Ø§Ù„Ø¹ÙŠØ¨: Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ù‚Ù„ points_value ÙƒÙ…Ø§ ÙÙŠ Ø§Ù„ÙˆØ«ÙŠÙ‚Ø©
# Ø§Ù„Ø­Ù„: Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù†Ø§Ù‚ØµØ©
points_reward = models.IntegerField(default=10)
excellence_points = models.IntegerField(default=5)
penalty_points = models.IntegerField(default=5)
Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø§Øª:
python# Ø§Ù„Ø¹ÙŠØ¨: Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Ø¸Ø§Ù… Ø¹Ø¯Ø§Ø¯ Ø°ÙƒÙŠ ÙƒÙ…Ø§ ÙÙŠ Ø§Ù„ÙˆØ«ÙŠÙ‚Ø©
# Ø§Ù„Ø­Ù„: Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¹Ø¯Ø§Ø¯ ÙÙŠ User model
def update_penalty_counter(self, change):
    self.penalty_counter = max(0, self.penalty_counter + change)
    self.is_muted = self.penalty_counter > 0
    self.save()
2. Ù†Ù‚Øµ ÙÙŠ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù

Ù„Ø§ ÙŠÙˆØ¬Ø¯ Telegram Bot
Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Ø¸Ø§Ù… ØªØµÙˆÙŠØª Ù„Ù„Ù…Ù†Ø§ÙØ³Ø©
Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒØ´Ù Ø§Ù„ØºØ´
Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ­Ù„ÙŠÙ„ Ø³Ù„ÙˆÙƒ

ğŸ“ Ø¥Ø¶Ø§ÙØ§Øª Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙˆØ±Ø§Ù‹
Ø¯Ø¹Ù†ÙŠ Ø£Ù†Ø´Ø¦ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†:

from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from django.utils import timezone
from core.models import BaseModel

class Competition(BaseModel):
    """Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
    
    class Type(models.TextChoices):
        INDIVIDUAL = 'individual', 'ÙØ±Ø¯ÙŠØ©'
        SECTION = 'section', 'Ø¨ÙŠÙ† Ø§Ù„Ø´Ø¹Ø¨'
        MIXED = 'mixed', 'Ù…Ø®ØªÙ„Ø·Ø©'
    
    class Status(models.TextChoices):
        UPCOMING = 'upcoming', 'Ù‚Ø§Ø¯Ù…Ø©'
        ACTIVE = 'active', 'Ù†Ø´Ø·Ø©'
        FINISHED = 'finished', 'Ù…Ù†ØªÙ‡ÙŠØ©'
        CANCELLED = 'cancelled', 'Ù…Ù„ØºÙŠØ©'
    
    class Period(models.TextChoices):
        DAILY = 'daily', 'ÙŠÙˆÙ…ÙŠØ©'
        WEEKLY = 'weekly', 'Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©'
        MONTHLY = 'monthly', 'Ø´Ù‡Ø±ÙŠØ©'
        SPECIAL = 'special', 'Ø®Ø§ØµØ©'
    
    title = models.CharField(max_length=200, verbose_name='Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    description = models.TextField(verbose_name='ÙˆØµÙ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    competition_type = models.CharField(max_length=20, choices=Type.choices, verbose_name='Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    period = models.CharField(max_length=20, choices=Period.choices, verbose_name='ÙØªØ±Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    status = models.CharField(max_length=20, choices=Status.choices, default=Status.UPCOMING, verbose_name='Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    
    start_date = models.DateTimeField(verbose_name='ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©')
    end_date = models.DateTimeField(verbose_name='ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©')
    
    # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
    sections = models.ManyToManyField('sections.Section', related_name='competitions', blank=True, verbose_name='Ø§Ù„Ø´Ø¹Ø¨ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©')
    max_participants = models.IntegerField(null=True, blank=True, validators=[MinValueValidator(1)], verbose_name='Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†')
    
    # Ù†Ø¸Ø§Ù… Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ø¬ÙˆØ§Ø¦Ø²
    early_submission_points = models.IntegerField(default=15, verbose_name='Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ³Ù„ÙŠÙ… Ø§Ù„Ù…Ø¨ÙƒØ±')
    on_time_points = models.IntegerField(default=10, verbose_name='Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ³Ù„ÙŠÙ… ÙÙŠ Ø§Ù„ÙˆÙ‚Øª')
    late_penalty = models.IntegerField(default=5, verbose_name='Ø¹Ù‚ÙˆØ¨Ø© Ø§Ù„ØªØ£Ø®ÙŠØ±')
    
    prize_structure = models.JSONField(default=dict, verbose_name='Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¬ÙˆØ§Ø¦Ø²', help_text='Ù…Ø«Ø§Ù„: {"1": 100, "2": 50, "3": 25}')
    
    # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
    auto_ranking = models.BooleanField(default=True, verbose_name='ØªØ±ØªÙŠØ¨ ØªÙ„Ù‚Ø§Ø¦ÙŠ')
    allow_voting = models.BooleanField(default=False, verbose_name='Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªØµÙˆÙŠØª')
    is_featured = models.BooleanField(default=False, verbose_name='Ù…Ø³Ø§Ø¨Ù‚Ø© Ù…Ù…ÙŠØ²Ø©')
    
    class Meta:
        verbose_name = 'Ù…Ø³Ø§Ø¨Ù‚Ø©'
        verbose_name_plural = 'Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª'
        db_table = 'competitions'
        ordering = ['-start_date']
    
    def __str__(self):
        return f"{self.title} ({self.get_competition_type_display()})"
    
    @property
    def is_active(self):
        now = timezone.now()
        return self.start_date <= now <= self.end_date and self.status == self.Status.ACTIVE
    
    @property
    def participant_count(self):
        return self.participants.count()

class CompetitionParticipant(BaseModel):
    """Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    competition = models.ForeignKey(Competition, on_delete=models.CASCADE, related_name='participants', verbose_name='Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    user = models.ForeignKey('users.User', on_delete=models.CASCADE, related_name='competition_participations', verbose_name='Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…')
    
    # Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„ØªØ±ØªÙŠØ¨
    total_score = models.IntegerField(default=0, verbose_name='Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©')
    submission_score = models.IntegerField(default=0, verbose_name='Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ³Ù„ÙŠÙ…')
    badge_score = models.IntegerField(default=0, verbose_name='Ù†Ù‚Ø§Ø· Ø§Ù„Ø´Ø§Ø±Ø§Øª')
    bonus_score = models.IntegerField(default=0, verbose_name='Ù†Ù‚Ø§Ø· Ø¥Ø¶Ø§ÙÙŠØ©')
    
    rank = models.IntegerField(null=True, blank=True, verbose_name='Ø§Ù„ØªØ±ØªÙŠØ¨')
    previous_rank = models.IntegerField(null=True, blank=True, verbose_name='Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø³Ø§Ø¨Ù‚')
    
    # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    submissions_count = models.IntegerField(default=0, verbose_name='Ø¹Ø¯Ø¯ Ø§Ù„ØªØ³Ù„ÙŠÙ…Ø§Øª')
    early_submissions = models.IntegerField(default=0, verbose_name='Ø§Ù„ØªØ³Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ù…Ø¨ÙƒØ±Ø©')
    late_submissions = models.IntegerField(default=0, verbose_name='Ø§Ù„ØªØ³Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ù…ØªØ£Ø®Ø±Ø©')
    
    joined_at = models.DateTimeField(auto_now_add=True, verbose_name='ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…')
    last_activity = models.DateTimeField(auto_now=True, verbose_name='Ø¢Ø®Ø± Ù†Ø´Ø§Ø·')
    
    class Meta:
        verbose_name = 'Ù…Ø´Ø§Ø±Ùƒ Ù…Ø³Ø§Ø¨Ù‚Ø©'
        verbose_name_plural = 'Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª'
        db_table = 'competition_participants'
        unique_together = ['competition', 'user']
        ordering = ['-total_score', 'joined_at']
    
    def __str__(self):
        return f"{self.user.get_full_name()} - {self.competition.title}"
    
    def calculate_total_score(self):
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©"""
        self.total_score = self.submission_score + self.badge_score + self.bonus_score
        self.save()
        return self.total_score

class SectionCompetition(BaseModel):
    """ØªÙ†Ø§ÙØ³ Ø§Ù„Ø´Ø¹Ø¨"""
    
    competition = models.ForeignKey(Competition, on_delete=models.CASCADE, related_name='section_battles', verbose_name='Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    section = models.ForeignKey('sections.Section', on_delete=models.CASCADE, related_name='competitions', verbose_name='Ø§Ù„Ø´Ø¹Ø¨Ø©')
    
    # Ù†Ù‚Ø§Ø· Ø§Ù„Ø´Ø¹Ø¨Ø©
    total_points = models.IntegerField(default=0, verbose_name='Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©')
    average_score = models.FloatField(default=0.0, verbose_name='Ø§Ù„Ù…ØªÙˆØ³Ø·')
    participant_count = models.IntegerField(default=0, verbose_name='Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†')
    
    # ØªØ±ØªÙŠØ¨ Ø§Ù„Ø´Ø¹Ø¨Ø©
    rank = models.IntegerField(null=True, blank=True, verbose_name='ØªØ±ØªÙŠØ¨ Ø§Ù„Ø´Ø¹Ø¨Ø©')
    previous_rank = models.IntegerField(null=True, blank=True, verbose_name='Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø³Ø§Ø¨Ù‚')
    
    class Meta:
        verbose_name = 'ØªÙ†Ø§ÙØ³ Ø´Ø¹Ø¨Ø©'
        verbose_name_plural = 'ØªÙ†Ø§ÙØ³ Ø§Ù„Ø´Ø¹Ø¨'
        db_table = 'section_competitions'
        unique_together = ['competition', 'section']
        ordering = ['-total_points']
    
    def __str__(self):
        return f"{self.section.name} - {self.competition.title}"

class CompetitionRound(BaseModel):
    """Ø¬ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    competition = models.ForeignKey(Competition, on_delete=models.CASCADE, related_name='rounds', verbose_name='Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    round_number = models.IntegerField(verbose_name='Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆÙ„Ø©')
    title = models.CharField(max_length=200, verbose_name='Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¬ÙˆÙ„Ø©')
    description = models.TextField(blank=True, verbose_name='ÙˆØµÙ Ø§Ù„Ø¬ÙˆÙ„Ø©')
    
    start_date = models.DateTimeField(verbose_name='ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¬ÙˆÙ„Ø©')
    end_date = models.DateTimeField(verbose_name='ØªØ§Ø±ÙŠØ® Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø¬ÙˆÙ„Ø©')
    
    points_multiplier = models.FloatField(default=1.0, validators=[MinValueValidator(0.1), MaxValueValidator(5.0)], verbose_name='Ù…Ø¶Ø§Ø¹Ù Ø§Ù„Ù†Ù‚Ø§Ø·')
    
    class Meta:
        verbose_name = 'Ø¬ÙˆÙ„Ø© Ù…Ø³Ø§Ø¨Ù‚Ø©'
        verbose_name_plural = 'Ø¬ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª'
        db_table = 'competition_rounds'
        unique_together = ['competition', 'round_number']
        ordering = ['round_number']
    
    def __str__(self):
        return f"{self.competition.title} - Ø§Ù„Ø¬ÙˆÙ„Ø© {self.round_number}"

class CompetitionVote(BaseModel):
    """ØªØµÙˆÙŠØª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    competition = models.ForeignKey(Competition, on_delete=models.CASCADE, related_name='votes', verbose_name='Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    voter = models.ForeignKey('users.User', on_delete=models.CASCADE, related_name='competition_votes', verbose_name='Ø§Ù„Ù…ØµÙˆØª')
    candidate = models.ForeignKey('users.User', on_delete=models.CASCADE, related_name='received_votes', verbose_name='Ø§Ù„Ù…Ø±Ø´Ø­')
    
    vote_weight = models.IntegerField(default=1, validators=[MinValueValidator(1), MaxValueValidator(5)], verbose_name='ÙˆØ²Ù† Ø§Ù„ØªØµÙˆÙŠØª')
    comment = models.TextField(blank=True, verbose_name='ØªØ¹Ù„ÙŠÙ‚')
    
    class Meta:
        verbose_name = 'ØªØµÙˆÙŠØª Ù…Ø³Ø§Ø¨Ù‚Ø©'
        verbose_name_plural = 'ØªØµÙˆÙŠØªØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª'
        db_table = 'competition_votes'
        unique_together = ['competition', 'voter', 'candidate']
    
    def __str__(self):
        return f"{self.voter.get_full_name()} ØµÙˆØª Ù„Ù€ {self.candidate.get_full_name()}"

class CompetitionReward(BaseModel):
    """Ø¬ÙˆØ§Ø¦Ø² Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    class RewardType(models.TextChoices):
        POINTS = 'points', 'Ù†Ù‚Ø§Ø·'
        BADGE = 'badge', 'Ø´Ø§Ø±Ø©'
        CERTIFICATE = 'certificate', 'Ø´Ù‡Ø§Ø¯Ø©'
        SPECIAL = 'special', 'Ø¬Ø§Ø¦Ø²Ø© Ø®Ø§ØµØ©'
    
    competition = models.ForeignKey(Competition, on_delete=models.CASCADE, related_name='rewards', verbose_name='Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©')
    participant = models.ForeignKey(CompetitionParticipant, on_delete=models.CASCADE, related_name='rewards', verbose_name='Ø§Ù„Ù…Ø´Ø§Ø±Ùƒ')
    
    reward_type = models.CharField(max_length=20, choices=RewardType.choices, verbose_name='Ù†ÙˆØ¹ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©')
    title = models.CharField(max_length=200, verbose_name='Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©')
    description = models.TextField(verbose_name='ÙˆØµÙ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©')
    
    points_value = models.IntegerField(default=0, verbose_name='Ù‚ÙŠÙ…Ø© Ø§Ù„Ù†Ù‚Ø§Ø·')
    badge = models.ForeignKey('badges.Badge', on_delete=models.SET_NULL, null=True, blank=True, verbose_name='Ø§Ù„Ø´Ø§Ø±Ø©')
    
    awarded_at = models.DateTimeField(auto_now_add=True, verbose_name='ØªØ§Ø±ÙŠØ® Ù…Ù†Ø­ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø©')
    
    class Meta:
        verbose_name = 'Ø¬Ø§Ø¦Ø²Ø© Ù…Ø³Ø§Ø¨Ù‚Ø©'
        verbose_name_plural = 'Ø¬ÙˆØ§Ø¦Ø² Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª'
        db_table = 'competition_rewards'
    
    def __str__(self):
        return f"{self.title} - {self.participant.user.get_full_name()}"



# homework_bot_system/api_service/apps/analytics/anti_cheat.py

from django.db import models
from django.utils import timezone
from datetime import timedelta
from apps.submissions.models import Submission
from apps.users.models import User
import numpy as np
from sklearn.ensemble import IsolationForest

class AntiCheatSystem:
    """Ù†Ø¸Ø§Ù… ÙƒØ´Ù Ø§Ù„ØºØ´ ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©"""
    
    @staticmethod
    def check_mass_approval(admin_user, submissions):
        """
        ÙƒØ´Ù Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠØ© Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
        """
        # Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø¨ÙŠÙ† Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª
        approval_times = [s.reviewed_at for s in submissions if s.reviewed_at]
        
        if len(approval_times) < 2:
            return False, "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§ÙÙ‚Ø§Øª ÙƒØ§ÙÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„"
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„ÙØªØ±Ø§Øª Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª
        intervals = []
        for i in range(1, len(approval_times)):
            interval = (approval_times[i] - approval_times[i-1]).total_seconds()
            intervals.append(interval)
        
        avg_interval = np.mean(intervals)
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆØ³Ø· Ø§Ù„ÙˆÙ‚Øª Ø¨ÙŠÙ† Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª Ø£Ù‚Ù„ Ù…Ù† 10 Ø«ÙˆØ§Ù†ÙŠ = Ù…Ø´Ø¨ÙˆÙ‡
        if avg_interval < 10:
            return True, f"Ù…ÙˆØ§ÙÙ‚Ø© Ø¬Ù…Ø§Ø¹ÙŠØ© Ù…Ø´Ø¨ÙˆÙ‡Ø©: Ù…ØªÙˆØ³Ø· {avg_interval:.2f} Ø«Ø§Ù†ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª"
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ÙˆØ§ÙÙ‚Ø© Ø£ÙƒØ«Ø± Ù…Ù† 10 ÙˆØ§Ø¬Ø¨Ø§Øª ÙÙŠ 5 Ø¯Ù‚Ø§Ø¦Ù‚
        if len(approval_times) > 10:
            time_span = (approval_times[-1] - approval_times[0]).total_seconds() / 60
            if time_span < 5:
                return True, f"Ù…ÙˆØ§ÙÙ‚Ø© {len(approval_times)} ÙˆØ§Ø¬Ø¨ ÙÙŠ {time_span:.2f} Ø¯Ù‚ÙŠÙ‚Ø©"
        
        return False, "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…Ø´Ø¨ÙˆÙ‡Ø©"
    
    @staticmethod
    def analyze_submission_patterns(student_user):
        """
        ØªØ­Ù„ÙŠÙ„ Ø£Ù†Ù…Ø§Ø· ØªØ³Ù„ÙŠÙ… Ø§Ù„Ø·Ø§Ù„Ø¨
        """
        submissions = Submission.objects.filter(
            student=student_user
        ).order_by('created_at')
        
        if submissions.count() < 5:
            return {
                'pattern': 'new_student',
                'usual_time': None,
                'usual_day': None,
                'is_consistent': False
            }
        
        # ØªØ­Ù„ÙŠÙ„ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ØªØ³Ù„ÙŠÙ…
        submission_hours = [s.created_at.hour for s in submissions]
        submission_days = [s.created_at.weekday() for s in submissions]
        
        # Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹ØªØ§Ø¯
        usual_hour = max(set(submission_hours), key=submission_hours.count)
        
        # Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ù…Ø¹ØªØ§Ø¯
        usual_day = max(set(submission_days), key=submission_days.count)
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø«Ø¨Ø§Øª
        hour_consistency = submission_hours.count(usual_hour) / len(submission_hours)
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Ù…Ø·
        late_count = sum(1 for s in submissions if s.is_late)
        late_ratio = late_count / submissions.count()
        
        if late_ratio > 0.7:
            pattern = 'always_late'
        elif late_ratio < 0.1:
            pattern = 'always_on_time'
        elif hour_consistency > 0.7:
            pattern = 'consistent'
        else:
            pattern = 'irregular'
        
        return {
            'pattern': pattern,
            'usual_time': usual_hour,
            'usual_day': usual_day,
            'is_consistent': hour_consistency > 0.7,
            'late_ratio': late_ratio
        }
    
    @staticmethod
    def detect_copying_patterns(submissions_batch):
        """
        ÙƒØ´Ù Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù†Ø³Ø® Ø¨ÙŠÙ† Ø§Ù„ØªØ³Ù„ÙŠÙ…Ø§Øª
        """
        # Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ØªØ³Ù„ÙŠÙ…Ø§Øª ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆØ§Ø¬Ø¨
        similar_submissions = []
        
        for i, sub1 in enumerate(submissions_batch):
            for j, sub2 in enumerate(submissions_batch[i+1:], i+1):
                # Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰
                if sub1.content and sub2.content:
                    similarity = AntiCheatSystem._calculate_similarity(
                        sub1.content, sub2.content
                    )
                    
                    if similarity > 0.9:  # ØªØ´Ø§Ø¨Ù‡ Ø¹Ø§Ù„ÙŠ Ø¬Ø¯Ø§Ù‹
                        similar_submissions.append({
                            'submission1': sub1,
                            'submission2': sub2,
                            'similarity': similarity
                        })
        
        return similar_submissions
    
    @staticmethod
    def _calculate_similarity(text1, text2):
        """Ø­Ø³Ø§Ø¨ Ù†Ø³Ø¨Ø© Ø§Ù„ØªØ´Ø§Ø¨Ù‡ Ø¨ÙŠÙ† Ù†ØµÙŠÙ†"""
        # Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø¨Ø³ÙŠØ·Ø© Ù„Ù„ØªØ´Ø§Ø¨Ù‡
        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())
        
        if not words1 or not words2:
            return 0
        
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        
        return len(intersection) / len(union)


class StudentBehaviorAnalyzer:
    """Ù…Ø­Ù„Ù„ Ø³Ù„ÙˆÙƒ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
    
    def __init__(self, student):
        self.student = student
        self.submissions = Submission.objects.filter(
            student=student
        ).order_by('created_at')
    
    def get_personality_type(self):
        """ØªØ­Ø¯ÙŠØ¯ Ø´Ø®ØµÙŠØ© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø³Ù„ÙˆÙƒÙ‡"""
        if self.submissions.count() < 3:
            return 'new_student'
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª
        late_ratio = self._calculate_late_ratio()
        avg_time_before_deadline = self._calculate_avg_time_before_deadline()
        consistency_score = self._calculate_consistency_score()
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®ØµÙŠØ©
        if late_ratio < 0.1 and avg_time_before_deadline > 24:
            return 'early_bird'  # Ø§Ù„Ø·Ø§Ø¦Ø± Ø§Ù„Ù…Ø¨ÙƒØ±
        elif late_ratio > 0.7:
            return 'procrastinator'  # Ø§Ù„Ù…Ù…Ø§Ø·Ù„
        elif consistency_score > 0.8:
            return 'steady_worker'  # Ø§Ù„Ø¹Ø§Ù…Ù„ Ø§Ù„Ù…Ø³ØªÙ‚Ø±
        else:
            return 'unpredictable'  # ØºÙŠØ± Ù…Ù†ØªØ¸Ù…
    
    def _calculate_late_ratio(self):
        """Ø­Ø³Ø§Ø¨ Ù†Ø³Ø¨Ø© Ø§Ù„ØªØ£Ø®ÙŠØ±"""
        if not self.submissions:
            return 0
        
        late_count = self.submissions.filter(is_late=True).count()
        return late_count / self.submissions.count()
    
    def _calculate_avg_time_before_deadline(self):
        """Ù…ØªÙˆØ³Ø· Ø§Ù„ÙˆÙ‚Øª Ù‚Ø¨Ù„ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ (Ø¨Ø§Ù„Ø³Ø§Ø¹Ø§Øª)"""
        times = []
        
        for sub in self.submissions:
            if not sub.is_late and sub.assignment.deadline:
                time_diff = sub.assignment.deadline - sub.created_at
                times.append(time_diff.total_seconds() / 3600)
        
        return np.mean(times) if times else 0
    
    def _calculate_consistency_score(self):
        """Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„Ø«Ø¨Ø§Øª ÙÙŠ Ø§Ù„Ø³Ù„ÙˆÙƒ"""
        if self.submissions.count() < 5:
            return 0
        
        # ØªØ­Ù„ÙŠÙ„ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ØªØ³Ù„ÙŠÙ…
        hours = [s.created_at.hour for s in self.submissions]
        days = [s.created_at.weekday() for s in self.submissions]
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¨Ø§ÙŠÙ†
        hour_variance = np.var(hours)
        day_variance = np.var(days)
        
        # Ø¯Ø±Ø¬Ø© Ø§Ù„Ø«Ø¨Ø§Øª (Ø¹ÙƒØ³ Ø§Ù„ØªØ¨Ø§ÙŠÙ†)
        consistency = 1 / (1 + hour_variance + day_variance)
        
        return min(consistency, 1.0)
    
    def predict_submission_time(self, assignment_deadline):
        """Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨ÙˆÙ‚Øª ØªØ³Ù„ÙŠÙ… Ø§Ù„Ø·Ø§Ù„Ø¨"""
        personality = self.get_personality_type()
        
        if personality == 'early_bird':
            # ÙŠØ³Ù„Ù… Ù‚Ø¨Ù„ 48 Ø³Ø§Ø¹Ø© Ø¹Ø§Ø¯Ø©
            predicted_time = assignment_deadline - timedelta(hours=48)
        elif personality == 'procrastinator':
            # ÙŠØ³Ù„Ù… ÙÙŠ Ø¢Ø®Ø± Ø³Ø§Ø¹Ø©
            predicted_time = assignment_deadline - timedelta(hours=1)
        elif personality == 'steady_worker':
            # ÙŠØ³Ù„Ù… Ù‚Ø¨Ù„ 24 Ø³Ø§Ø¹Ø©
            predicted_time = assignment_deadline - timedelta(hours=24)
        else:
            # ØºÙŠØ± Ù…Ù†ØªØ¸Ù… - Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØªÙˆØ³Ø·
            avg_hours = self._calculate_avg_time_before_deadline()
            predicted_time = assignment_deadline - timedelta(hours=avg_hours)
        
        return predicted_time
    
    def get_custom_message(self):
        """Ø±Ø³Ø§Ù„Ø© Ù…Ø®ØµØµØ© Ø­Ø³Ø¨ Ø´Ø®ØµÙŠØ© Ø§Ù„Ø·Ø§Ù„Ø¨"""
        personality = self.get_personality_type()
        name = self.student.first_name
        
        messages = {
            'early_bird': f"Ù…Ø§Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‡ {name}ØŒ Ø¯Ø§ÙŠÙ…Ø§Ù‹ Ø§Ù„Ø³Ø¨Ø§Ù‚! ğŸ† Ø§Ø³ØªÙ…Ø± Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªÙˆÙ‰",
            'procrastinator': f"ÙŠØ§ {name}ØŒ Ø´Ø¨ÙŠÙƒ Ø¯Ø§ÙŠÙ…Ø§Ù‹ ØªØ³Ù„Ù… Ø¢Ø®Ø± Ø¯Ù‚ÙŠÙ‚Ø©ØŸ ğŸ˜… Ø®Ù„ Ù†ØºÙŠØ± Ù‡Ø§Ù„Ø¹Ø§Ø¯Ø©",
            'steady_worker': f"Ø¹Ø§Ø´Øª Ø¥ÙŠØ¯Ùƒ {name}ØŒ Ù…Ù†ØªØ¸Ù… ÙˆÙ…Ø±ØªØ¨ ğŸ‘Œ",
            'unpredictable': f"ÙŠØ§ {name}ØŒ Ø®Ù„ÙŠÙ†Ø§ Ù†Ø­Ø§ÙˆÙ„ Ù†Ù†Ø¸Ù… ÙˆÙ‚ØªÙ†Ø§ Ø£ÙƒØ«Ø± ğŸ“…",
            'new_student': f"Ø£Ù‡Ù„Ø§Ù‹ {name}! Ù…Ù†ÙˆØ± Ø§Ù„Ø¨ÙˆØªØŒ Ø®Ù„ÙŠÙ†Ø§ Ù†Ø´ÙˆÙ Ø´Ù†Ùˆ Ø¹Ù†Ø¯Ùƒ ğŸ’ª"
        }
        
        return messages.get(personality, f"Ø£Ù‡Ù„Ø§Ù‹ {name}!")


class CompetitionFairnessChecker:
    """Ù…Ø¯Ù‚Ù‚ Ø¹Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª"""
    
    @staticmethod
    def check_section_admin_bias(competition):
        """
        Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ­ÙŠØ² Ø£Ø¯Ù…Ù† Ø§Ù„Ø´Ø¹Ø¨Ø© ÙÙŠ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø§Øª
        """
        from apps.sections.models import Section
        
        bias_reports = []
        
        for section in competition.sections.all():
            if not section.admin:
                continue
            
            # Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ù„Ø´Ø¹Ø¨Ø© Ø§Ù„Ø£Ø¯Ù…Ù†
            admin_section_approvals = Submission.objects.filter(
                assignment__section=section,
                status='approved',
                reviewed_by=section.admin,
                created_at__range=[competition.start_date, competition.end_date]
            ).count()
            
            admin_section_total = Submission.objects.filter(
                assignment__section=section,
                created_at__range=[competition.start_date, competition.end_date]
            ).count()
            
            if admin_section_total > 0:
                admin_approval_rate = admin_section_approvals / admin_section_total
                
                # Ù…Ù‚Ø§Ø±Ù†Ø© Ù…Ø¹ Ø§Ù„Ø´Ø¹Ø¨ Ø§Ù„Ø£Ø®Ø±Ù‰
                other_sections = competition.sections.exclude(id=section.id)
                other_approval_rates = []
                
                for other_section in other_sections:
                    other_approvals = Submission.objects.filter(
                        assignment__section=other_section,
                        status='approved',
                        created_at__range=[competition.start_date, competition.end_date]
                    ).count()
                    
                    other_total = Submission.objects.filter(
                        assignment__section=other_section,
                        created_at__range=[competition.start_date, competition.end_date]
                    ).count()
                    
                    if other_total > 0:
                        other_approval_rates.append(other_approvals / other_total)
                
                if other_approval_rates:
                    avg_other_rate = np.mean(other_approval_rates)
                    
                    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø¹Ø¯Ù„ Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ø£Ø¯Ù…Ù† Ø£Ø¹Ù„Ù‰ Ø¨Ù€ 20% = Ù…Ø´Ø¨ÙˆÙ‡
                    if admin_approval_rate > avg_other_rate * 1.2:
                        bias_reports.append({
                            'section': section,
                            'admin': section.admin,
                            'approval_rate': admin_approval_rate,
                            'average_other_rate': avg_other_rate,
                            'bias_percentage': ((admin_approval_rate / avg_other_rate) - 1) * 100
                        })
        
        return bias_reports


2. ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Django Ù„Ø¥Ø¶Ø§ÙØ© ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª

# Local apps
    'core',
    'apps.users',
    'apps.sections',
    'apps.assignments',
    'apps.submissions',
    'apps.competitions',  # Ø¥Ø¶Ø§ÙØ© ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯
    'apps.badges',
    'apps.analytics',
]


3. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„ÙØ§Øª ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª
Ù„Ù†Ø¨Ø¯Ø£ Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø§Ù‚ÙŠ Ù…Ù„ÙØ§Øª ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª:
# homework_bot_system/api_service/apps/competitions/serializers.py

from rest_framework import serializers
from django.utils import timezone
from .models import (
    Competition, CompetitionParticipant, SectionCompetition,
    CompetitionRound, CompetitionVote, CompetitionReward
)
from apps.users.serializers import UserBasicSerializer
from apps.sections.serializers import SectionBasicSerializer
from apps.badges.serializers import BadgeSerializer

class CompetitionSerializer(serializers.ModelSerializer):
    """Ù…Ø³Ù„Ø³Ù„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ"""
    
    competition_type_display = serializers.CharField(source='get_competition_type_display', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    period_display = serializers.CharField(source='get_period_display', read_only=True)
    
    participant_count = serializers.IntegerField(read_only=True)
    is_active = serializers.BooleanField(read_only=True)
    
    class Meta:
        model = Competition
        fields = [
            'id', 'title', 'description', 'competition_type', 'competition_type_display',
            'period', 'period_display', 'status', 'status_display',
            'start_date', 'end_date', 'max_participants', 'participant_count',
            'early_submission_points', 'on_time_points', 'late_penalty',
            'prize_structure', 'auto_ranking', 'allow_voting', 'is_featured',
            'is_active', 'created_at', 'updated_at'
        ]
        read_only_fields = ['created_at', 'updated_at']
    
    def validate(self, data):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
        if data.get('start_date') and data.get('end_date'):
            if data['start_date'] >= data['end_date']:
                raise serializers.ValidationError("ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©")
        
        if data.get('start_date') and data['start_date'] < timezone.now():
            if not self.instance:  # Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙŠØ¯
                raise serializers.ValidationError("Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ")
        
        return data

class CompetitionParticipantSerializer(serializers.ModelSerializer):
    """Ù…Ø³Ù„Ø³Ù„ Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    user = UserBasicSerializer(read_only=True)
    competition_title = serializers.CharField(source='competition.title', read_only=True)
    rank_change = serializers.SerializerMethodField()
    
    class Meta:
        model = CompetitionParticipant
        fields = [
            'id', 'user', 'competition', 'competition_title',
            'total_score', 'submission_score', 'badge_score', 'bonus_score',
            'rank', 'previous_rank', 'rank_change',
            'submissions_count', 'early_submissions', 'late_submissions',
            'joined_at', 'last_activity'
        ]
        read_only_fields = ['joined_at', 'last_activity']
    
    def get_rank_change(self, obj):
        """Ø­Ø³Ø§Ø¨ ØªØºÙŠÙŠØ± Ø§Ù„ØªØ±ØªÙŠØ¨"""
        if obj.previous_rank and obj.rank:
            return obj.previous_rank - obj.rank  # Ù…ÙˆØ¬Ø¨ = ØªØ­Ø³Ù†ØŒ Ø³Ø§Ù„Ø¨ = ØªØ±Ø§Ø¬Ø¹
        return 0

class SectionCompetitionSerializer(serializers.ModelSerializer):
    """Ù…Ø³Ù„Ø³Ù„ ØªÙ†Ø§ÙØ³ Ø§Ù„Ø´Ø¹Ø¨"""
    
    section = SectionBasicSerializer(read_only=True)
    competition_title = serializers.CharField(source='competition.title', read_only=True)
    rank_change = serializers.SerializerMethodField()
    
    class Meta:
        model = SectionCompetition
        fields = [
            'id', 'section', 'competition', 'competition_title',
            'total_points', 'average_score', 'participant_count',
            'rank', 'previous_rank', 'rank_change'
        ]
    
    def get_rank_change(self, obj):
        if obj.previous_rank and obj.rank:
            return obj.previous_rank - obj.rank
        return 0

class CompetitionRoundSerializer(serializers.ModelSerializer):
    """Ù…Ø³Ù„Ø³Ù„ Ø¬ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    class Meta:
        model = CompetitionRound
        fields = [
            'id', 'competition', 'round_number', 'title', 'description',
            'start_date', 'end_date', 'points_multiplier'
        ]
    
    def validate(self, data):
        if data.get('start_date') and data.get('end_date'):
            if data['start_date'] >= data['end_date']:
                raise serializers.ValidationError("ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¬ÙˆÙ„Ø© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ©")
        return data

class CompetitionVoteSerializer(serializers.ModelSerializer):
    """Ù…Ø³Ù„Ø³Ù„ ØªØµÙˆÙŠØª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    voter = UserBasicSerializer(read_only=True)
    candidate = UserBasicSerializer(read_only=True)
    
    class Meta:
        model = CompetitionVote
        fields = [
            'id', 'competition', 'voter', 'candidate',
            'vote_weight', 'comment', 'created_at'
        ]
        read_only_fields = ['created_at']

class CompetitionRewardSerializer(serializers.ModelSerializer):
    """Ù…Ø³Ù„Ø³Ù„ Ø¬ÙˆØ§Ø¦Ø² Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    participant = CompetitionParticipantSerializer(read_only=True)
    badge = BadgeSerializer(read_only=True)
    reward_type_display = serializers.CharField(source='get_reward_type_display', read_only=True)
    
    class Meta:
        model = CompetitionReward
        fields = [
            'id', 'competition', 'participant', 'reward_type', 'reward_type_display',
            'title', 'description', 'points_value', 'badge', 'awarded_at'
        ]
        read_only_fields = ['awarded_at']

class CompetitionDetailSerializer(CompetitionSerializer):
    """Ù…Ø³Ù„Ø³Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    participants = CompetitionParticipantSerializer(many=True, read_only=True)
    section_battles = SectionCompetitionSerializer(many=True, read_only=True)
    rounds = CompetitionRoundSerializer(many=True, read_only=True)
    top_participants = serializers.SerializerMethodField()
    my_participation = serializers.SerializerMethodField()
    
    class Meta(CompetitionSerializer.Meta):
        fields = CompetitionSerializer.Meta.fields + [
            'participants', 'section_battles', 'rounds', 
            'top_participants', 'my_participation'
        ]
    
    def get_top_participants(self, obj):
        """Ø£ÙØ¶Ù„ 10 Ù…Ø´Ø§Ø±ÙƒÙŠÙ†"""
        top_participants = obj.participants.order_by('-total_score')[:10]
        return CompetitionParticipantSerializer(top_participants, many=True).data
    
    def get_my_participation(self, obj):
        """Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ"""
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            try:
                participation = obj.participants.get(user=request.user)
                return CompetitionParticipantSerializer(participation).data
            except CompetitionParticipant.DoesNotExist:
                return None
        return None

class CompetitionStatsSerializer(serializers.Serializer):
    """Ù…Ø³Ù„Ø³Ù„ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª"""
    
    total_competitions = serializers.IntegerField()
    active_competitions = serializers.IntegerField()
    finished_competitions = serializers.IntegerField()
    total_participants = serializers.IntegerField()
    average_participants_per_competition = serializers.FloatField()
    most_popular_competition = CompetitionSerializer()
    top_performers = CompetitionParticipantSerializer(many=True)
# homework_bot_system/api_service/apps/competitions/views.py

from django.db.models import Q, Count, Sum, Avg, F
from django.utils import timezone
from django.shortcuts import get_object_or_404
from rest_framework import viewsets, status, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import filters

from .models import (
    Competition, CompetitionParticipant, SectionCompetition,
    CompetitionRound, CompetitionVote, CompetitionReward
)
from .serializers import (
    CompetitionSerializer, CompetitionDetailSerializer,
    CompetitionParticipantSerializer, SectionCompetitionSerializer,
    CompetitionRoundSerializer, CompetitionVoteSerializer,
    CompetitionRewardSerializer, CompetitionStatsSerializer
)
from .utils import CompetitionCalculator, CompetitionRewardManager, CompetitionAnalytics
from core.permissions import IsOwnerOrReadOnly, IsTeacherOrReadOnly

class CompetitionViewSet(viewsets.ModelViewSet):
    """Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©"""
    
    queryset = Competition.objects.all()
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['competition_type', 'status', 'period', 'is_featured']
    search_fields = ['title', 'description']
    ordering_fields = ['start_date', 'end_date', 'participant_count']
    ordering = ['-start_date']
    
    def get_serializer_class(self):
        if self.action == 'retrieve':
            return CompetitionDetailSerializer
        return CompetitionSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ø´Ø¹Ø¨Ø©
        section_id = self.request.query_params.get('section')
        if section_id:
            queryset = queryset.filter(sections__id=section_id)
        
        # ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
        if self.request.query_params.get('my_competitions') == 'true':
            if self.request.user.is_authenticated:
                queryset = queryset.filter(participants__user=self.request.user)
        
        return queryset.annotate(
            participant_count=Count('participants')
        ).distinct()
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def join(self, request, pk=None):
        """Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
        competition = self.get_object()
        user = request.user
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
        if competition.status != Competition.Status.UPCOMING:
            return Response(
                {'error': 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© ØºÙŠØ± Ù‚Ø§Ø¯Ù…Ø©'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        if competition.max_participants:
            if competition.participant_count >= competition.max_participants:
                return Response(
                    {'error': 'ØªÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†'},
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
        if CompetitionParticipant.objects.filter(competition=competition, user=user).exists():
            return Response(
                {'error': 'Ø£Ù†Øª Ù…Ø´Ø§Ø±Ùƒ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
        participant = CompetitionParticipant.objects.create(
            competition=competition,
            user=user
        )
        
        # ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø´Ø¹Ø¨Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© ØªØ´Ù…Ù„ Ø§Ù„Ø´Ø¹Ø¨
        if competition.competition_type in [Competition.Type.SECTION, Competition.Type.MIXED]:
            if hasattr(user, 'section') and user.section:
                section_competition, created = SectionCompetition.objects.get_or_create(
                    competition=competition,
                    section=user.section,
                    defaults={'participant_count': 0}
                )
                section_competition.participant_count = F('participant_count') + 1
                section_competition.save()
        
        serializer = CompetitionParticipantSerializer(participant)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def leave(self, request, pk=None):
        """Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
        competition = self.get_object()
        user = request.user
        
        try:
            participant = CompetitionParticipant.objects.get(
                competition=competition, user=user
            )
            
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ù…ØºØ§Ø¯Ø±Ø©
            if competition.status == Competition.Status.ACTIVE:
                return Response(
                    {'error': 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù…ØºØ§Ø¯Ø±Ø© Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø©'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            participant.delete()
            
            # ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø´Ø¹Ø¨Ø©
            if competition.competition_type in [Competition.Type.SECTION, Competition.Type.MIXED]:
                if hasattr(user, 'section') and user.section:
                    try:
                        section_competition = SectionCompetition.objects.get(
                            competition=competition, section=user.section
                        )
                        section_competition.participant_count = F('participant_count') - 1
                        section_competition.save()
                    except SectionCompetition.DoesNotExist:
                        pass
            
            return Response({'message': 'ØªÙ… ØªØ±Ùƒ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­'})
            
        except CompetitionParticipant.DoesNotExist:
            return Response(
                {'error': 'Ø£Ù†Øª Ù„Ø³Øª Ù…Ø´Ø§Ø±Ùƒ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©'},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def active(self, request):
        """Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©"""
        now = timezone.now()
        active_competitions = self.get_queryset().filter(
            start_date__lte=now,
            end_date__gte=now,
            status=Competition.Status.ACTIVE
        )
        
        serializer = self.get_serializer(active_competitions, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def featured(self, request):
        """Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ù…ÙŠØ²Ø©"""
        featured_competitions = self.get_queryset().filter(is_featured=True)
        serializer = self.get_serializer(featured_competitions, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'], permission_classes=[IsAuthenticated])
    def my_competitions(self, request):
        """Ù…Ø³Ø§Ø¨Ù‚Ø§ØªÙŠ"""
        user_competitions = self.get_queryset().filter(
            participants__user=request.user
        )
        serializer = self.get_serializer(user_competitions, many=True)
        return Response(serializer.data)
    
    @action(detail=True, methods=['get'])
    def leaderboard(self, request, pk=None):
        """Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†"""
        competition = self.get_object()
        participants = competition.participants.order_by('-total_score', 'joined_at')
        
        # ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØµÙÙŠØ©
        section_id = request.query_params.get('section')
        if section_id:
            participants = participants.filter(user__section__id=section_id)
        
        # Ø§Ù„ØªØµÙØ­
        page = self.paginate_queryset(participants)
        if page is not None:
            serializer = CompetitionParticipantSerializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = CompetitionParticipantSerializer(participants, many=True)
        return Response(serializer.data)
    
    @action(detail=True, methods=['get'])
    def section_battles(self, request, pk=None):
        """Ù…Ø¹Ø§Ø±Ùƒ Ø§Ù„Ø´Ø¹Ø¨"""
        competition = self.get_object()
        
        if competition.competition_type not in [Competition.Type.SECTION, Competition.Type.MIXED]:
            return Response(
                {'error': 'Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ø§ ØªØ¯Ø¹Ù… Ù…Ø¹Ø§Ø±Ùƒ Ø§Ù„Ø´Ø¹Ø¨'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        section_battles = competition.section_battles.order_by('-total_points')
        serializer = SectionCompetitionSerializer(section_battles, many=True)
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'], permission_classes=[IsTeacherOrReadOnly])
    def update_rankings(self, request, pk=None):
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ±ØªÙŠØ¨"""
        competition = self.get_object()
        
        # ØªØ­Ø¯ÙŠØ« Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        CompetitionCalculator.update_participant_scores(competition)
        
        # ØªØ­Ø¯ÙŠØ« ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        CompetitionCalculator.update_participant_rankings(competition)
        
        # ØªØ­Ø¯ÙŠØ« ØªØ±ØªÙŠØ¨ Ø§Ù„Ø´Ø¹Ø¨
        if competition.competition_type in [Competition.Type.SECTION, Competition.Type.MIXED]:
            CompetitionCalculator.update_section_rankings(competition)
        
        return Response({'message': 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ±ØªÙŠØ¨ Ø¨Ù†Ø¬Ø§Ø­'})
    
    @action(detail=True, methods=['post'], permission_classes=[IsTeacherOrReadOnly])
    def award_prizes(self, request, pk=None):
        """Ù…Ù†Ø­ Ø§Ù„Ø¬ÙˆØ§Ø¦Ø²"""
        competition = self.get_object()
        
        if competition.status != Competition.Status.FINISHED:
            return Response(
                {'error': 'ÙŠÙ…ÙƒÙ† Ù…Ù†Ø­ Ø§Ù„Ø¬ÙˆØ§Ø¦Ø² ÙÙ‚Ø· Ù„Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Ù…Ù†Ø­ Ø§Ù„Ø¬ÙˆØ§Ø¦Ø²
        rewards = CompetitionRewardManager.award_competition_prizes(competition)
        
        serializer = CompetitionRewardSerializer(rewards, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª"""
        stats = CompetitionAnalytics.get_general_stats()
        serializer = CompetitionStatsSerializer(stats)
        return Response(serializer.data)

class CompetitionParticipantViewSet(viewsets.ReadOnlyModelViewSet):
    """Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¹Ø±Ø¶ Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    queryset = CompetitionParticipant.objects.all()
    serializer_class = CompetitionParticipantSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [DjangoFilterBackend, filters.OrderingFilter]
    filterset_fields = ['competition', 'user']
    ordering_fields = ['total_score', 'rank', 'joined_at']
    ordering = ['-total_score']

class CompetitionVoteViewSet(viewsets.ModelViewSet):
    """Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¹Ø±Ø¶ ØªØµÙˆÙŠØªØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    queryset = CompetitionVote.objects.all()
    serializer_class = CompetitionVoteSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        return super().get_queryset().filter(voter=self.request.user)
    
    def perform_create(self, serializer):
        serializer.save(voter=self.request.user)

class CompetitionRewardViewSet(viewsets.ReadOnlyModelViewSet):
    """Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¹Ø±Ø¶ Ø¬ÙˆØ§Ø¦Ø² Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
    
    queryset = CompetitionReward.objects.all()
    serializer_class = CompetitionRewardSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['competition', 'participant', 'reward_type']

# homework_bot_system/api_service/apps/competitions/utils.py

from django.db.models import Sum, Avg, Count, Q
from django.utils import timezone
from .models import Competition, CompetitionParticipant, SectionCompetition
from apps.submissions.models import Submission
from apps.badges.models import UserBadge

class CompetitionCalculator:
    """Ø­Ø§Ø³Ø¨Ø© Ù†Ù‚Ø§Ø· ÙˆÙ…Ø±Ø§ØªØ¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª"""
    
    @staticmethod
    def calculate_participant_score(participant):
        """Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø´Ø§Ø±Ùƒ"""
        user = participant.user
        competition = participant.competition
        
        # Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ³Ù„ÙŠÙ…Ø§Øª
        submission_score = CompetitionCalculator._calculate_submission_score(
            user, competition
        )
        
        # Ù†Ù‚Ø§Ø· Ø§Ù„Ø´Ø§Ø±Ø§Øª
        badge_score = CompetitionCalculator._calculate_badge_score(
            user, competition
        )
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ù‚Ø§Ø·
        participant.submission_score = submission_score
        participant.badge_score = badge_score
        participant.total_score = submission_score + badge_score + participant.bonus_score
        participant.save()
        
        return participant.total_score
    
    @staticmethod
    def _calculate_submission_score(user, competition):
        """Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ³Ù„ÙŠÙ…Ø§Øª"""
        submissions = Submission.objects.filter(
            user=user,
            assignment__sections__competitions=competition,
            created_at__range=[competition.start_date, competition.end_date]
        )
        
        total_score = 0
        early_count = 0
        late_count = 0
        
        for submission in submissions:
            assignment = submission.assignment
            submission_time = submission.created_at
            
            # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„ØªØ³Ù„ÙŠÙ…
            if submission_time <= assignment.due_date:
                # ØªØ³Ù„ÙŠÙ… ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø£Ùˆ Ù…Ø¨ÙƒØ±
                days_early = (assignment.due_date - submission_time).days
                if days_early >= 1:  # ØªØ³Ù„ÙŠÙ… Ù…Ø¨ÙƒØ±
                    total_score += competition.early_submission_points
                    early_count += 1
                else:  # ØªØ³Ù„ÙŠÙ… ÙÙŠ Ø§Ù„ÙˆÙ‚Øª
                    total_score += competition.on_time_points
            else:
                # ØªØ³Ù„ÙŠÙ… Ù…ØªØ£Ø®Ø±
                total_score -= competition.late_penalty
                late_count += 1
        
        # ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø´Ø§Ø±Ùƒ
        participant = CompetitionParticipant.objects.get(
            user=user, competition=competition
        )
        participant.submissions_count = submissions.count()
        participant.early_submissions = early_count
        participant.late_submissions = late_count
        participant.save()
        
        return max(0, total_score)  # Ù„Ø§ ØªÙ‚Ù„ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¹Ù† ØµÙØ±
    
    @staticmethod
    def _calculate_badge_score(user, competition):
        """Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ø´Ø§Ø±Ø§Øª"""
        user_badges = UserBadge.objects.filter(
            user=user,
            earned_at__range=[competition.start_date, competition.end_date]
        )
        
        total_score = 0
        for user_badge in user_badges:
            badge = user_badge.badge
            # Ù†Ù‚Ø§Ø· Ù…Ø®ØªÙ„ÙØ© Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø´Ø§Ø±Ø©
            if badge.badge_type == 'gold':
                total_score += 50
            elif badge.badge_type == 'silver':
                total_score += 30
            elif badge.badge_type == 'bronze':
                total_score += 20
            else:
                total_score += 10
        
        return total_score
    
    @staticmethod
    def update_rankings(competition):
        """ØªØ­Ø¯ÙŠØ« ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†"""
        participants = competition.participants.order_by('-total_score', 'joined_at')
        
        for index, participant in enumerate(participants, 1):
            participant.previous_rank = participant.rank
            participant.rank = index
            participant.save()
    
    @staticmethod
    def update_section_rankings(competition):
        """ØªØ­Ø¯ÙŠØ« ØªØ±ØªÙŠØ¨ Ø§Ù„Ø´Ø¹Ø¨"""
        section_competitions = competition.section_battles.all()
        
        for section_comp in section_competitions:
            # Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ø´Ø¹Ø¨Ø©
            participants = competition.participants.filter(
                user__section=section_comp.section
            )
            
            total_points = participants.aggregate(
                total=Sum('total_score')
            )['total'] or 0
            
            average_score = participants.aggregate(
                avg=Avg('total_score')
            )['avg'] or 0
            
            participant_count = participants.count()
            
            section_comp.total_points = total_points
            section_comp.average_score = round(average_score, 2)
            section_comp.participant_count = participant_count
            section_comp.save()
        
        # ØªØ±ØªÙŠØ¨ Ø§Ù„Ø´Ø¹Ø¨
        section_competitions = competition.section_battles.order_by(
            '-total_points', '-average_score'
        )
        
        for index, section_comp in enumerate(section_competitions, 1):
            section_comp.previous_rank = section_comp.rank
            section_comp.rank = index
            section_comp.save()
    
    @staticmethod
    def auto_update_competition(competition):
        """ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
        if not competition.auto_ranking:
            return
        
        # ØªØ­Ø¯ÙŠØ« Ù†Ù‚Ø§Ø· Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        for participant in competition.participants.all():
            CompetitionCalculator.calculate_participant_score(participant)
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ±ØªÙŠØ¨Ø§Øª
        CompetitionCalculator.update_rankings(competition)
        CompetitionCalculator.update_section_rankings(competition)

class CompetitionRewardManager:
    """Ù…Ø¯ÙŠØ± Ø¬ÙˆØ§Ø¦Ø² Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª"""
    
    @staticmethod
    def award_competition_prizes(competition):
        """Ù…Ù†Ø­ Ø¬ÙˆØ§Ø¦Ø² Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©"""
        if competition.status != Competition.Status.FINISHED:
            return
        
        top_participants = competition.participants.order_by('-total_score')[:10]
        prize_structure = competition.prize_structure
        
        for index, participant in enumerate(top_participants, 1):
            rank_str = str(index)
            if rank_str in prize_structure:
                points = prize_structure[rank_str]
                
                # Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø§Ø¦Ø²Ø©
                CompetitionReward.objects.create(
                    competition=competition,
                    participant=participant,
                    reward_type=CompetitionReward.RewardType.POINTS,
                    title=f"Ø§Ù„Ù…Ø±ÙƒØ² {index}",
                    description=f"Ø¬Ø§Ø¦Ø²Ø© Ø§Ù„Ù…Ø±ÙƒØ² {index} ÙÙŠ {competition.title}",
                    points_value=points
                )
                
                # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· Ù„Ù„Ù…Ø´Ø§Ø±Ùƒ
                participant.bonus_score += points
                participant.save()

class CompetitionAnalytics:
    """ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª"""
    
    @staticmethod
    def get_competition_stats():
        """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¹Ø§Ù…Ø© Ù„Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª"""
        now = timezone.now()
        
        total_competitions = Competition.objects.count()
        active_competitions = Competition.objects.filter(
            start_date__lte=now,
            end_date__gte=now,
            status=Competition.Status.ACTIVE
        ).count()
        
        finished_competitions = Competition.objects.filter(
            status=Competition.Status.FINISHED
        ).count()
        
        total_participants = CompetitionParticipant.objects.count()
        
        avg_participants = CompetitionParticipant.objects.values(
            'competition'
        ).annotate(
            count=Count('id')
        ).aggregate(
            avg=Avg('count')
        )['avg'] or 0
        
        # Ø£ÙƒØ«Ø± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø´Ø¹Ø¨ÙŠØ©
        most_popular = Competition.objects.annotate(
            participant_count=Count('participants')
        ).order_by('-participant_count').first()
        
        # Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ø¤Ø¯ÙŠÙ†
        top_performers = CompetitionParticipant.objects.order_by(
            '-total_score'
        )[:5]
        
        return {
            'total_competitions': total_competitions,
            'active_competitions': active_competitions,
            'finished_competitions': finished_competitions,
            'total_participants': total_participants,
            'average_participants_per_competition': round(avg_participants, 2),
            'most_popular_competition': most_popular,
            'top_performers': top_performers
        }

# homework_bot_system/api_service/apps/competitions/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import (
    CompetitionViewSet, CompetitionParticipantViewSet,
    CompetitionVoteViewSet, CompetitionRewardViewSet
)

router = DefaultRouter()
router.register(r'competitions', CompetitionViewSet)
router.register(r'participants', CompetitionParticipantViewSet)
router.register(r'votes', CompetitionVoteViewSet)
router.register(r'rewards', CompetitionRewardViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

# homework_bot_system/api_service/apps/competitions/admin.py

from django.contrib import admin
from .models import (
    Competition, CompetitionParticipant, SectionCompetition,
    CompetitionRound, CompetitionVote, CompetitionReward
)

@admin.register(Competition)
class CompetitionAdmin(admin.ModelAdmin):
    list_display = ['title', 'competition_type', 'status', 'start_date', 'end_date', 'participant_count']
    list_filter = ['competition_type', 'status', 'period', 'is_featured']
    search_fields = ['title', 'description']
    filter_horizontal = ['sections']
    readonly_fields = ['participant_count']
    
    fieldsets = (
        ('Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©', {
            'fields': ('title', 'description', 'competition_type', 'period', 'status')
        }),
        ('Ø§Ù„ØªÙˆÙ‚ÙŠØª', {
            'fields': ('start_date', 'end_date')
        }),
        ('Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©', {
            'fields': ('sections', 'max_participants')
        }),
        ('Ù†Ø¸Ø§Ù… Ø§Ù„Ù†Ù‚Ø§Ø·', {
            'fields': ('early_submission_points', 'on_time_points', 'late_penalty', 'prize_structure')
        }),
        ('Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©', {
            'fields': ('auto_ranking', 'allow_voting', 'is_featured')
        })
    )

@admin.register(CompetitionParticipant)
class CompetitionParticipantAdmin(admin.ModelAdmin):
    list_display = ['user', 'competition', 'total_score', 'rank', 'joined_at']
    list_filter = ['competition', 'joined_at']
    search_fields = ['user__username', 'user__first_name', 'user__last_name', 'competition__title']
    readonly_fields = ['total_score', 'joined_at', 'last_activity']

@admin.register(SectionCompetition)
class SectionCompetitionAdmin(admin.ModelAdmin):
    list_display = ['section', 'competition', 'total_points', 'rank', 'participant_count']
    list_filter = ['competition']
    readonly_fields = ['total_points', 'average_score', 'participant_count']

@admin.register(CompetitionRound)
class CompetitionRoundAdmin(admin.ModelAdmin):
    list_display = ['competition', 'round_number', 'title', 'start_date', 'end_date']
    list_filter = ['competition']
    ordering = ['competition', 'round_number']

@admin.register(CompetitionVote)
class CompetitionVoteAdmin(admin.ModelAdmin):
    list_display = ['voter', 'candidate', 'competition', 'vote_weight', 'created_at']
    list_filter = ['competition', 'vote_weight', 'created_at']
    search_fields = ['voter__username', 'candidate__username']

@admin.register(CompetitionReward)
class CompetitionRewardAdmin(admin.ModelAdmin):
    list_display = ['participant', 'competition', 'reward_type', 'title', 'points_value', 'awarded_at']
    list_filter = ['reward_type', 'competition', 'awarded_at']
    search_fields = ['participant__user__username', 'title']

# homework_bot_system/api_service/apps/competitions/tests.py

from django.test import TestCase
from django.contrib.auth import get_user_model
from django.utils import timezone
from datetime import timedelta
from rest_framework.test import APITestCase
from rest_framework import status

from .models import Competition, CompetitionParticipant
from apps.sections.models import Section

User = get_user_model()

class CompetitionModelTest(TestCase):
    def setUp(self):
        self.competition = Competition.objects.create(
            title='Ù…Ø³Ø§Ø¨Ù‚Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ©',
            description='ÙˆØµÙ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©',
            competition_type=Competition.Type.INDIVIDUAL,
            period=Competition.Period.WEEKLY,
            start_date=timezone.now() + timedelta(days=1),
            end_date=timezone.now() + timedelta(days=8)
        )
    
    def test_competition_creation(self):
        self.assertEqual(self.competition.title, 'Ù…Ø³Ø§Ø¨Ù‚Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ©')
        self.assertEqual(self.competition.status, Competition.Status.UPCOMING)
    
    def test_is_active_property(self):
        # Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ù… ØªØ¨Ø¯Ø£ Ø¨Ø¹Ø¯
        self.assertFalse(self.competition.is_active)
        
        # ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
        self.competition.start_date = timezone.now() - timedelta(hours=1)
        self.competition.status = Competition.Status.ACTIVE
        self.competition.save()
        
        self.assertTrue(self.competition.is_active)

class CompetitionAPITest(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        
        self.section = Section.objects.create(
            name='Ø§Ù„Ø´Ø¹Ø¨Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰',
            code='SEC001'
        )
        
        self.competition = Competition.objects.create(
            title='Ù…Ø³Ø§Ø¨Ù‚Ø© API',
            description='Ø§Ø®ØªØ¨Ø§Ø± API',
            competition_type=Competition.Type.INDIVIDUAL,
            period=Competition.Period.WEEKLY,
            start_date=timezone.now() + timedelta(days=1),
            end_date=timezone.now() + timedelta(days=8)
        )
    
    def test_list_competitions(self):
        response = self.client.get('/api/v1/competitions/competitions/')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
    
    def test_join_competition(self):
        self.client.force_authenticate(user=self.user)
        response = self.client.post(f'/api/v1/competitions/competitions/{self.competition.id}/join/')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
        self.assertTrue(
            CompetitionParticipant.objects.filter(
                competition=self.competition,
                user=self.user
            ).exists()
        )
    
    def test_join_competition_twice(self):
        self.client.force_authenticate(user=self.user)
        
        # Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø§Ù„Ø£ÙˆÙ„
        self.client.post(f'/api/v1/competitions/competitions/{self.competition.id}/join/')
        
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
        response = self.client.post(f'/api/v1/competitions/competitions/{self.competition.id}/join/')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

# homework_bot_system/api_service/apps/competitions/apps.py

from django.apps import AppConfig

class CompetitionsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.competitions'
    verbose_name = 'Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª'

# homework_bot_system/api_service/apps/competitions/tasks.py

from celery import shared_task
from django.utils import timezone
from .models import Competition
from .utils import CompetitionCalculator, CompetitionRewardManager

@shared_task
def update_competition_status():
    """ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹"""
    now = timezone.now()
    
    # ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©
    upcoming_competitions = Competition.objects.filter(
        status=Competition.Status.UPCOMING,
        start_date__lte=now
    )
    
    for competition in upcoming_competitions:
        competition.status = Competition.Status.ACTIVE
        competition.save()
    
    # Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
    active_competitions = Competition.objects.filter(
        status=Competition.Status.ACTIVE,
        end_date__lte=now
    )
    
    for competition in active_competitions:
        competition.status = Competition.Status.FINISHED
        competition.save()
        
        # Ù…Ù†Ø­ Ø§Ù„Ø¬ÙˆØ§Ø¦Ø² ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
        CompetitionRewardManager.award_competition_prizes(competition)
    
    return f"ØªÙ… ØªØ­Ø¯ÙŠØ« {upcoming_competitions.count() + active_competitions.count()} Ù…Ø³Ø§Ø¨Ù‚Ø©"

@shared_task
def update_competition_rankings():
    """ØªØ­Ø¯ÙŠØ« ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©"""
    active_competitions = Competition.objects.filter(
        status=Competition.Status.ACTIVE,
        auto_ranking=True
    )
    
    updated_count = 0
    for competition in active_competitions:
        CompetitionCalculator.update_participant_scores(competition)
        CompetitionCalculator.update_participant_rankings(competition)
        
        if competition.competition_type in [Competition.Type.SECTION, Competition.Type.MIXED]:
            CompetitionCalculator.update_section_rankings(competition)
        
        updated_count += 1
    
    return f"ØªÙ… ØªØ­Ø¯ÙŠØ« ØªØ±ØªÙŠØ¨ {updated_count} Ù…Ø³Ø§Ø¨Ù‚Ø©"

@shared_task
def calculate_daily_competition_stats():
    """Ø­Ø³Ø§Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©"""
    from .utils import CompetitionAnalytics
    
    stats = CompetitionAnalytics.get_general_stats()
    
    # ÙŠÙ…ÙƒÙ† Ø­ÙØ¸ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ùˆ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª
    return f"ØªÙ… Ø­Ø³Ø§Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª {stats['total_competitions']} Ù…Ø³Ø§Ø¨Ù‚Ø©"

# API v1
    path('api/v1/auth/', include('apps.authentication.urls')),
    path('api/v1/users/', include('apps.users.urls')),
    path('api/v1/sections/', include('apps.sections.urls')),
    path('api/v1/assignments/', include('apps.assignments.urls')),
    path('api/v1/submissions/', include('apps.submissions.urls')),
    path('api/v1/competitions/', include('apps.competitions.urls')),
    path('api/v1/badges/', include('apps.badges.urls')),
    path('api/v1/analytics/', include('apps.analytics.urls')),
    path('api/v1/notifications/', include('apps.notifications.urls')),


# homework_bot_system/api_service/apps/notifications/models.py

from django.db import models
from core.models import BaseModel

class Notification(BaseModel):
    """Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª"""
    
    class Type(models.TextChoices):
        ASSIGNMENT = 'assignment', 'ÙˆØ§Ø¬Ø¨ Ø¬Ø¯ÙŠØ¯'
        SUBMISSION = 'submission', 'ØªØ³Ù„ÙŠÙ…'
        COMPETITION = 'competition', 'Ù…Ø³Ø§Ø¨Ù‚Ø©'
        REMINDER = 'reminder', 'ØªØ°ÙƒÙŠØ±'
        WARNING = 'warning', 'ØªØ­Ø°ÙŠØ±'
        ACHIEVEMENT = 'achievement', 'Ø¥Ù†Ø¬Ø§Ø²'
        PENALTY = 'penalty', 'Ø¹Ù‚ÙˆØ¨Ø©'
        SYSTEM = 'system', 'Ù†Ø¸Ø§Ù…'
    
    class Status(models.TextChoices):
        PENDING = 'pending', 'ÙÙŠ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±'
        SENT = 'sent', 'Ù…ÙØ±Ø³Ù„'
        FAILED = 'failed', 'ÙØ´Ù„'
        READ = 'read', 'Ù…Ù‚Ø±ÙˆØ¡'
    
    user = models.ForeignKey(
        'users.User',
        on_delete=models.CASCADE,
        related_name='notifications',
        verbose_name='Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…'
    )
    
    notification_type = models.CharField(
        max_length=20,
        choices=Type.choices,
        verbose_name='Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±'
    )
    
    title = models.CharField(
        max_length=200,
        verbose_name='Ø§Ù„Ø¹Ù†ÙˆØ§Ù†'
    )
    
    message = models.TextField(
        verbose_name='Ø§Ù„Ø±Ø³Ø§Ù„Ø©'
    )
    
    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        verbose_name='Ø§Ù„Ø­Ø§Ù„Ø©'
    )
    
    is_urgent = models.BooleanField(
        default=False,
        verbose_name='Ø¹Ø§Ø¬Ù„'
    )
    
    scheduled_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Ù…ÙˆØ¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„'
    )
    
    sent_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='ÙˆÙ‚Øª Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙØ¹Ù„ÙŠ'
    )
    
    read_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='ÙˆÙ‚Øª Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©'
    )
    
    # Ø±Ø¨Ø· Ø¨Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø®Ø±Ù‰
    assignment = models.ForeignKey(
        'assignments.Assignment',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='notifications',
        verbose_name='Ø§Ù„ÙˆØ§Ø¬Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·'
    )
    
    competition = models.ForeignKey(
        'competitions.Competition',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='notifications',
        verbose_name='Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©'
    )
    
    extra_data = models.JSONField(
        default=dict,
        blank=True,
        verbose_name='Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©'
    )
    
    telegram_message_id = models.BigIntegerField(
        null=True,
        blank=True,
        verbose_name='Ù…Ø¹Ø±Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙ„ÙƒØ±Ø§Ù…'
    )
    
    class Meta:
        verbose_name = 'Ø¥Ø´Ø¹Ø§Ø±'
        verbose_name_plural = 'Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª'
        db_table = 'notifications'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['notification_type']),
            models.Index(fields=['scheduled_at']),
        ]
    
    def __str__(self):
        return f"{self.title} - {self.user.get_full_name()}"
    
    def mark_as_sent(self):
        """ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± ÙƒÙ…ÙØ±Ø³Ù„"""
        self.status = self.Status.SENT
        self.sent_at = timezone.now()
        self.save()
    
    def mark_as_read(self):
        """ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± ÙƒÙ…Ù‚Ø±ÙˆØ¡"""
        self.status = self.Status.READ
        self.read_at = timezone.now()
        self.save()

class NotificationTemplate(BaseModel):
    """Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª"""
    
    notification_type = models.CharField(
        max_length=20,
        choices=Notification.Type.choices,
        unique=True,
        verbose_name='Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±'
    )
    
    title_template = models.CharField(
        max_length=200,
        verbose_name='Ù‚Ø§Ù„Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†',
        help_text='Ø§Ø³ØªØ®Ø¯Ù… {variable} Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª'
    )
    
    message_template = models.TextField(
        verbose_name='Ù‚Ø§Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ù„Ø©',
        help_text='Ø§Ø³ØªØ®Ø¯Ù… {variable} Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª'
    )
    
    is_active = models.BooleanField(
        default=True,
        verbose_name='Ù†Ø´Ø·'
    )
    
    class Meta:
        verbose_name = 'Ù‚Ø§Ù„Ø¨ Ø¥Ø´Ø¹Ø§Ø±'
        verbose_name_plural = 'Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª'
        db_table = 'notification_templates'
    
    def __str__(self):
        return f"Ù‚Ø§Ù„Ø¨ {self.get_notification_type_display()}"
# homework_bot_system/api_service/apps/notifications/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter

router = DefaultRouter()

urlpatterns = [
    path('', include(router.urls)),
]
# homework_bot_system/api_service/apps/notifications/__init__.py

# ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª

class TelegramAuthMiddleware(MiddlewareMixin):
    """Middleware Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ØµØ§Ø¯Ù‚Ø© Ø§Ù„ØªÙ„ÙƒØ±Ø§Ù…"""
    
    def process_request(self, request):
        # ØªØ¬Ø§Ù‡Ù„ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
        excluded_paths = ['/admin/', '/api/docs/', '/api/auth/login/']
        if any(request.path.startswith(path) for path in excluded_paths):
            return None
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø±Ù…Ø² Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©
        auth_header = request.META.get('HTTP_AUTHORIZATION')
        if not auth_header or not auth_header.startswith('Bearer '):
            return JsonResponse({
                'error': 'Ù…Ø·Ù„ÙˆØ¨ Ø±Ù…Ø² Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©',
                'message': 'ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹'
            }, status=401)
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø±Ù…Ø²
        token = auth_header.split(' ')[1]
        
        try:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ù…Ø² (Ø³ÙŠØªÙ… ØªÙ†ÙÙŠØ°Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹)
            user = self.verify_token(token)
            if not user:
                return JsonResponse({
                    'error': 'Ø±Ù…Ø² Ù…ØµØ§Ø¯Ù‚Ø© ØºÙŠØ± ØµØ­ÙŠØ­',
                    'message': 'ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰'
                }, status=401)
            
            # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ø·Ù„Ø¨
            request.user = user
            
        except Exception as e:
            logger.error(f"Token verification error: {str(e)}")
            return JsonResponse({
                'error': 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©',
                'message': 'ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹'
            }, status=500)
        
        return None
    
    def verify_token(self, token):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ù…Ù…ÙŠØ²"""
        # Ø³ÙŠØªÙ… ØªÙ†ÙÙŠØ° Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ¸ÙŠÙØ© Ù…Ø¹ JWT Ù„Ø§Ø­Ù‚Ø§Ù‹
        return None


class ActivityLogMiddleware(MiddlewareMixin):
    """Middleware Ù„ØªØ³Ø¬ÙŠÙ„ Ø£Ù†Ø´Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†"""
    
    def process_request(self, request):
        request.start_time = time.time()
        return None
    
    def process_response(self, request, response):
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ø´Ø§Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„
        if hasattr(request, 'user') and request.user.is_authenticated:
            # Ø­Ø³Ø§Ø¨ ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
            duration = time.time() - getattr(request, 'start_time', time.time())
            
            # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ø´Ø§Ø·
            from apps.analytics.models import ActivityLog
            
            ActivityLog.objects.create(
                user=request.user,
                action='api_request',
                description=f"{request.method} {request.path}",
                ip_address=self.get_client_ip(request),
                user_agent=request.META.get('HTTP_USER_AGENT', ''),
                extra_data={
                    'method': request.method,
                    'path': request.path,
                    'status_code': response.status_code,
                    'duration': round(duration, 3)
                }
            )
            
            # ØªØ­Ø¯ÙŠØ« Ø¢Ø®Ø± Ù†Ø´Ø§Ø· Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
            request.user.update_activity()
        
        return response
    
    def get_client_ip(self, request):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ IP Ø§Ù„Ø¹Ù…ÙŠÙ„"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
ğŸ“‹ Ù…Ù„Ø®Øµ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª ÙˆØ§Ù„Ø¥Ø¶Ø§ÙØ§Øª
Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø¥Ø¶Ø§ÙØ© ÙˆØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:
1. ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù… âœ…

apps/competitions/models.py - Ù†Ù…Ø§Ø°Ø¬ Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª
apps/competitions/serializers.py - Ù…Ø³Ù„Ø³Ù„Ø§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
apps/competitions/views.py - Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø¹Ø±Ø¶
apps/competitions/utils.py - Ø£Ø¯ÙˆØ§Øª Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø·
apps/competitions/urls.py - Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
apps/competitions/admin.py - ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©
apps/competitions/tests.py - Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª
apps/competitions/tasks.py - Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø©
apps/competitions/apps.py - Ø§Ù„ØªÙƒÙˆÙŠÙ†
apps/competitions/__init__.py - Ù…Ù„Ù Ø§Ù„ØªÙ‡ÙŠØ¦Ø©

2. Ù†Ø¸Ø§Ù… Ù…Ù†Ø¹ Ø§Ù„ØºØ´ ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© âœ…

apps/analytics/anti_cheat.py - Ù†Ø¸Ø§Ù… ÙƒØ´Ù Ø§Ù„ØºØ´

3. ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ âœ…

apps/notifications/models.py - Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
apps/notifications/urls.py - Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
apps/notifications/__init__.py - Ù…Ù„Ù Ø§Ù„ØªÙ‡ÙŠØ¦Ø©

4. ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© âœ…

ØªØ­Ø¯ÙŠØ« config/settings/base.py - Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
ØªØ­Ø¯ÙŠØ« config/urls.py - Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª ÙˆØ§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
ØªØ­Ø¯ÙŠØ« core/middleware.py - Ø¥Ø¶Ø§ÙØ© ActivityLogMiddleware

ğŸš¨ Ù…Ø§ Ø§Ù„Ø°ÙŠ ØªØ¨Ù‚Ù‰ Ø¨Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ù‚ØµÙˆÙ‰ØŸ
1. Ø¨ÙˆØª Ø§Ù„ØªÙ„ÙƒØ±Ø§Ù… (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø£Ø¹Ù„Ù‰) ğŸ”´
homework_bot_system/
â”œâ”€â”€ telegram_bot/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ bot.py              # Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
â”‚   â”œâ”€â”€ handlers/           # Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£ÙˆØ§Ù…Ø±
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ start.py
â”‚   â”‚   â”œâ”€â”€ student.py
â”‚   â”‚   â”œâ”€â”€ admin.py
â”‚   â”‚   â””â”€â”€ competition.py
â”‚   â”œâ”€â”€ keyboards/          # Ù„ÙˆØ­Ø§Øª Ø§Ù„Ù…ÙØ§ØªÙŠØ­
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ student_kb.py
â”‚   â”‚   â””â”€â”€ admin_kb.py
â”‚   â”œâ”€â”€ utils/             # Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø©
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ api_client.py  # Ù„Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Django API
â”‚   â”‚   â””â”€â”€ messages.py
â”‚   â””â”€â”€ config.py          # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª
2. Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ğŸŸ¡

Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³Ù„ÙˆÙƒ
Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ØªØ³Ù„ÙŠÙ…
Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø®ØµØµØ© Ø§Ù„Ø°ÙƒÙŠØ©

3. WebSocket Ù„Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ© ğŸŸ¡

Django Channels
Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ÙÙˆØ±ÙŠØ©
ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ø§Ù„Ø­ÙŠØ©

4. Ù†Ø¸Ø§Ù… Caching Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ğŸŸ¢

Redis caching
ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡
ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª

5. Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ø´Ø§Ù…Ù„Ø© ğŸŸ¢

Unit tests
Integration tests
Performance tests

ğŸ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ø§Ù„Ù…ÙˆØµÙ‰ Ø¨Ù‡Ø§
Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø§Ù„ØªÙ„ÙƒØ±Ø§Ù…
bash# Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø¨ÙˆØª
mkdir -p homework_bot_system/telegram_bot
cd homework_bot_system/telegram_bot

# ØªØ«Ø¨ÙŠØª Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ø¨ÙˆØª
pip install python-telegram-bot[ext] aiohttp
Ø§Ù„Ø®Ø·ÙˆØ© 2: ØªØ´ØºÙŠÙ„ Django migrations
bashcd homework_bot_system/api_service
python manage.py makemigrations
python manage.py migrate
python manage.py createsuperuser
Ø§Ù„Ø®Ø·ÙˆØ© 3: Ø¥Ø¹Ø¯Ø§Ø¯ Celery
bash# ØªØ´ØºÙŠÙ„ Redis
redis-server

# ØªØ´ØºÙŠÙ„ Celery worker
celery -A config worker --loglevel=info

# ØªØ´ØºÙŠÙ„ Celery beat
celery -A config beat --loglevel=info
Ø§Ù„Ø®Ø·ÙˆØ© 4: ØªØ´ØºÙŠÙ„ Ø®Ø§Ø¯Ù… Ø§Ù„ØªØ·ÙˆÙŠØ±
bashpython manage.py runserver
ğŸ’¡ ØªÙˆØµÙŠØ§Øª Ø¥Ø¶Ø§ÙÙŠØ©

Ø§Ø³ØªØ®Ø¯Ù… Docker Ù„ØªØ³Ù‡ÙŠÙ„ Ø§Ù„ØªØ·ÙˆÙŠØ± ÙˆØ§Ù„Ù†Ø´Ø±
Ø£Ø¶Ù Sentry Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
Ø§Ø³ØªØ®Ø¯Ù… GitHub Actions Ù„Ù€ CI/CD
Ø£Ø¶Ù Prometheus Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡
Ø§Ø³ØªØ®Ø¯Ù… Nginx ÙƒÙ€ reverse proxy

ğŸ‰ Ø§Ù„Ø®Ù„Ø§ØµØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø¢Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:

âœ… Ù‡ÙŠÙƒÙ„ Django REST API Ù…ØªÙƒØ§Ù…Ù„
âœ… Ù†Ø¸Ø§Ù… Ù…Ø³Ø§Ø¨Ù‚Ø§Øª Ù…ØªÙ‚Ø¯Ù…
âœ… Ù†Ø¸Ø§Ù… Ù…Ù†Ø¹ Ø§Ù„ØºØ´
âœ… Ù†Ø¸Ø§Ù… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø£Ø³Ø§Ø³ÙŠ
âœ… Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„Ø§Øª Ù…ØªÙ‚Ø¯Ù…
âœ… Ù†Ø¸Ø§Ù… ØµÙ„Ø§Ø­ÙŠØ§Øª Ù…ØªØ¯Ø±Ø¬
âœ… JWT Ù„Ù„Ù…ØµØ§Ø¯Ù‚Ø©
â³ Ø¨ÙˆØª Ø§Ù„ØªÙ„ÙƒØ±Ø§Ù… (ÙŠØ­ØªØ§Ø¬ Ø¥Ù†Ø´Ø§Ø¡)
â³ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙ‚Ø¯Ù… (ÙŠØ­ØªØ§Ø¬ ØªØ·ÙˆÙŠØ±)

Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø§Ù‡Ø² Ø¨Ù†Ø³Ø¨Ø© 75% ÙˆØ¬Ø§Ù‡Ø² Ù„Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø§Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„ÙØ¹Ù„ÙŠ! ğŸš€